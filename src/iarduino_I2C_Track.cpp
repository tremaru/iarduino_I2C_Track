#include "iarduino_I2C_Track.h"																									//
																																//
//		Инициализация модуля:																									//	Возвращаемое значение:	результат инициализации.
bool	iarduino_I2C_Track::_begin			(uint8_t type, uint8_t p1, uint8_t p2, uint8_t p3, uint8_t p4){						//	Параметры:				type - тип модуля (знак/светофор), p1 - группа знака или перекрёсток светофора, p2 - номер знака или секции светофора [,p3 - пункт знака] [, p4 - табличка знака].
		//	Инициируем работу с шиной I2C:																						//
			selI2C->begin();																									//	Инициируем работу с выбранной шиной I2C в качестве мастера.
			delay(10);																											//
		//	Если адрес не указан, то ищим модуль на шине I2C:																	//
			if(valAddrTemp==0){																									//
				for(int i=1; i<127; i++){																						//	Проходим по всем адресам на шине I2C
					if( selI2C->checkAddress(i)											){	valAddr=i; delay(2);				//	Если на шине I2C есть устройство с адресом i, то используем этот адрес для проверки найденного модуля...
					if(_readBytes(REG_MODEL,4)											){										//	Читаем 4 байта начиная с регистра «REG_MODEL» в массив «data».
					if( data[0]     == DEF_MODEL_IR0     || data[0] == DEF_MODEL_IR1	){										//	Если у модуля с адресом i в регистре «MODEL»   (data[0]) хранится значение DEF_MODEL_IR0 или DEF_MODEL_IR1, то ...
					if((data[2]>>1) == i                 || data[2] == 0xFF				){										//	Если у модуля с адресом i в регистре «ADDRESS» (data[2]) хранится значение i (адрес+младший бит) или 0xFF (адрес не задавался), то ...
					if( data[3]     == DEF_CHIP_ID_FLASH || data[3] == DEF_CHIP_ID_METRO){										//	Если у модуля с адресом i в регистре «CHIP_ID» (data[3]) хранится значение DEF_CHIP_ID_FLASH (идентификатор модулей Flash), или DEF_CHIP_ID_METRO (идентификатор модулей Metro), то ...
						valAddrTemp=i; i=128;																					//	Считаем что модуль обнаружен, сохраняем значение i как найденный адрес и выходим из цикла.
					}}}}}																										//
				}																												//
			}																													//
		//	Если модуль не найден, то возвращаем ошибку инициализации:															//
			if( valAddrTemp == 0														){	valAddr=0; return false;}			//
		//	Проверяем наличие модуля на шине I2C:																				//
			if( selI2C->checkAddress(valAddrTemp) == false								){	valAddr=0; return false;}			//	Если на шине I2C нет устройств с адресом valAddrTemp, то возвращаем ошибку инициализации
			valAddr=valAddrTemp;																								//	Сохраняем адрес модуля на шине I2C.
		//	Проверяем значения регистров модуля:																				//
			if(_readBytes(REG_MODEL,4)==false											){	valAddr=0; return false;}			//	Если не удалось прочитать 4 байта в массив «data» из модуля начиная с регистра «REG_MODEL», то возвращаем ошибку инициализации.
			if( data[0]     != DEF_MODEL_IR0     && data[0] != DEF_MODEL_IR1			){	valAddr=0; return false;}			//	Если значение  регистра «MODEL»   (data[0]) не совпадает со значением DEF_MODEL_IR0 и не совпадает со значением DEF_MODEL_IR1, то возвращаем ошибку инициализации.
			if((data[2]>>1) != valAddrTemp       && data[2] !=0xFF						){	valAddr=0; return false;}			//	Если значение  регистра «ADDRESS» (data[2]) не совпадает с адресом модуля и не совпадает со значением 0xFF, то возвращаем ошибку инициализации.
			if( data[3]     != DEF_CHIP_ID_FLASH && data[3] != DEF_CHIP_ID_METRO		){	valAddr=0; return false;}			//	Если значение  регистра «CHIP_ID» (data[3]) не совпадает со значением DEF_CHIP_ID_FLASH и DEF_CHIP_ID_METRO, то возвращаем ошибку инициализации.
			valVers=data[1];																									//	Сохраняем байт регистра «VERSION» (data[1]) в переменую «valVers».
		//	Отключаем все цвета светофора (кроме жёлтого) и подсветку знаков:													//
			data[0]=0x08; if(_writeBytes(REG_IR1_DIGITAL,1)==false ){ return false; } delay(10);								//	Записываем 1 байт в регистр «DIGITAL» из массива «data». Сброс всех битов кроме жёлтого.
		//	Определяем адрес и команду передаваемые по ИК-каналу:																//
			if( (type==MODUL_TLIGHT) || (type==MODUL_TLIGHT_AUTO) ){															//
			//	Модуль должен работать как светофор, тип перекрёстка и наличие секций указаны в параметрах p1 и p2:				//
				if( (p1 & ~TRACK_LFR) || (!p1) ){ return false; }																//	Рараметр p1 может принимать значение         TRACK_L/F/R/LF/RF/LR/LFR.
				if(  p2 & ~SECTION_LGR         ){ return false; }																//	Рараметр p2 может принимать значение 0 или SECTION_L/G/R/LG/RG/LR/LGR.
				valIrAdrCom = (p1|(p2&SECTION_LR))<<8;																			//	Определяем адрес светофора с направлением движения на перекрёстке p1 и наличием секций поворота p2 без шлагбаума.
				flgGate = p2&SECTION_G?1:0;																						//	Определяем флаг наличия шлагбаума.
			//	Указываем модулю о наличии или отсутствии у него дополнительных секций:											//
				if(_readBytes(REG_IR1_TL_YEL_SEC,3)==false ){ return false; }													//	Читаем 3 байта начиная с регистра «TL_YEL_SEC» в массив «data».
				if( p2&SECTION_L ){ data[0] |= IR1_BIT_TL_LT_EN; }else{ data[0] &= ~IR1_BIT_TL_LT_EN; }							//	Устанавливаем бит «TL_LT_EN» регистра «TL_YEL_SEC».
				if( p2&SECTION_R ){ data[1] |= IR1_BIT_TL_RT_EN; }else{ data[1] &= ~IR1_BIT_TL_RT_EN; }							//	Устанавливаем бит «TL_RT_EN» регистра «TL_GRN_SEC».
				if( p2&SECTION_G ){ data[2] |= IR1_BIT_TL_GT_EN; }else{ data[2] &= ~IR1_BIT_TL_GT_EN; }							//	Устанавливаем бит «TL_GT_EN» регистра «TL_RED_SEC».
				if(_writeBytes(REG_IR1_TL_YEL_SEC,3)==false ){ return false; }													//	Записываем 3 байта начиная с регистра «TL_YEL_SEC» из массива «data».
			}else																												//
			if( type == MODUL_SIGN ){																							//
			//	Модуль должен работать как знак, в параметрах указаны: группа p1, номер p2, пункт p3 и табличка p4:				//
				if( p3 > 15 ){uint8_t p=p4; p4=p3; p3=p;}																		//	Если p3>15, то меняем местами p3 и p4.
				if( p4 > 15 ){ p4 -= 15; }else{ p4 = 0; }																		//	Параметр p4 может принимать значение 0 или значения констант от 15+1 до 15+7, преобразуем их в значения от 0 до 7.
				if( (!p1)   || (p1>7 ) ){ return false; }																		//	Параметр p1 должен содержать ГРУППУ знака от 1 до 7.
				if( (!p2)   || (p2>63) ){ return false; }																		//	Параметр p2 должен содержать НОМЕР  знака от 1 до 63
				if( (p3>15) || (p4>7 ) ){ return false; }																		//	Параметры p3 и p4 являются необязательными, они магут принимать значения от 0 до 15 и 7 соответственно.
				valIrAdrCom = (p1<<13) | (p2<<7) | (p3<<3) | p4;																//	Определяем адрес и команду знака = (ГРУППА<<13) | (НОМЕР<<7) | (ПУНКТ<<3) | ТАБЛИЧКА).
			}else																												//
			//	Тип модуля указан некорректно:																					//
			{	return false; }																									//
		//	Включаем ИК-передатчик и устанавливаем изменяемые интервалы между пакетами повторов:								//	
			if(_readBytes(REG_IR1_BIT,1)==false ){ return false; }																//	Читаем 1 байт из регистра «BIT» в массив «data».
			data[0] |= IR1_BIT_TX_SHIFT|IR1_BIT_TX_EN;																			//	Устанавливаем биты «BIT_TX_SHIFT» и «BIT_TX_EN».
			if(_writeBytes(REG_IR1_BIT,1)==false ){ return false; }																//	Записываем 1 байт в регистр «BIT» из массива «data».
		//	Сохраняем адрес ИК устройства:																						//
			data[0]=highByte(valIrAdrCom); if(_writeBytes(REG_IR1_SEND_ADR,1)==false ){ return false; }							//	Записываем 1 байт адреса в регистр «SEND_ADR» из массива «data». Это не приведёт к отправке данных по ИК-каналу, так как отправка выполняется после записи байта в регистр «SEND_COM».
		//	Отключаем автоматическую отправку ИК данных и определяем режим работы светофора:									//
			data[0]=(type==MODUL_TLIGHT_AUTO)? IR1_BIT_TL_AUTOJOB:0; if(_writeBytes(REG_IR1_TL_BIT,1)==false ){ return false; }	//	Записываем 1 байт в регистр «TL_BIT» из массива «data». Сброс бита «AUTOCOM» регистра «TL_BIT» приведёт к сбросу бита «REPEAT» регистра «SEND_RPT», что остановит любую передачу данных. Установка бита «TL_AUTOJOB» регистра «TL_BIT» вклюит режим автоматической работы светофора.
			return true;																										//	Возвращаем флаг успешной инициализаии.
}																																//
																																//
//		Перезагрузка модуля:																									//	Возвращаемое значение:	результат перезагрузки.
bool	iarduino_I2C_Track::reset			(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Устанавливаем бит перезагрузки:																					//
				if(_readBytes(REG_BITS_0,1)==false){return false;}																//	Читаем 1 байт регистра «BITS_0» в массив «data».
				data[0] |= 0b10000000;																							//	Устанавливаем бит «SET_RESET»
				if(_writeBytes(REG_BITS_0,1)==false){return false;}																//	Записываем 1 байт в регистр «BITS_0» из массива «data».
			//	Переинициируем шину в связи с программным отключением подтяжек шины I2C в модуле:								//
				delay(10); selI2C->begin();																						//	Ждём восстановление подтяжек линий SCL/SDA и переинициируем работу с шиной I2C.
			//	Ждём установки флага завершения перезагрузки:																	//
				do{ if(_readBytes(REG_FLAGS_0,1)==false){return false;} }														//	Читаем 1 байт регистра «REG_FLAGS_0» в массив «data».
				while( (data[0]&0b10000000) == 0);																				//	Повторяем чтение пока не установится флаг «FLG_RESET».
				return true;																									//
			}else{																												//	Иначе, если модуль не инициализирован, то ...
				return false;																									//	Возвращаем ошибку
			}																													//
}																																//
																																//
//		Смена адреса модуля:																									//	Возвращаемое значение:	резульат смены адреса.
bool	iarduino_I2C_Track::changeAddress	(uint8_t newAddr){																	//	Параметр:				newAddr - новый адрес модуля (0x07 < адрес < 0x7F).
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Проверяем новый адрес:																							//
				if(newAddr>0x7F){newAddr>>=1;}																					//	Корректируем адрес, если он указан с учётом бита RW.
				if(newAddr==0x00 || newAddr==0x7F){return false;}																//	Запрещаем устанавливать адрес 0x00 и 0x7F.
			//	Записываем новый адрес:																							//
				if(_readBytes(REG_BITS_0,1)==false){return false;}																//	Читаем 1 байт регистра «BITS_0» в массив «data».
				data[0] &= 0b11110111;																							//	Сбрасываем    бит «BLOCK_ADR».
				data[0] |= 0b00000010;																							//	Устанавливаем бит «SAVE_ADR_EN»
				if(_writeBytes(REG_BITS_0,1)==false){return false;}																//	Записываем 1 байт в регистр «BITS_0» из массива «data».
				data[0] = (newAddr<<1)|0x01;																					//	Готовим новый адрес к записи в модуль, установив бит «SAVE_FLASH».
				if(_writeBytes(REG_ADDRESS,1)==false){return false;}															//	Записываем 1 байт в регистр «ADDRESS» из массива «data».
				delay(200);																										//	Даём более чем достаточное время для применения модулем нового адреса.
			//	Проверяем наличие модуля с новым адресом на шине I2C:															//
				if(selI2C->checkAddress(newAddr)==false){return false;}															//	Если на шине I2C нет модуля с адресом newAddr, то возвращаем ошибку.
				valAddr     = newAddr;																							//	Сохраняем новый адрес как текущий.
				valAddrTemp = newAddr;																							//	Сохраняем новый адрес как указанный.
				return true;																									//	Возвращаем флаг успеха.
			}else{																												//	Иначе, если модуль не инициализирован, то ...
				return false;																									//	Возвращаем ошибку
			}																													//
}																																//
																																//
//		Получение флага наличия подтяжки линий шины I2C:																		//	Возвращаемое значение:	флаг наличия подтяжки линий шины I2C.
bool	iarduino_I2C_Track::getPullI2C		(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Считываем первые два регистра: регистр флагов и регистр битов:													//
				if(_readBytes(REG_FLAGS_0,2)==false ){ return false; }															//	Читаем 2 байта начиная с регистра «REG_FLAGS_0» в массив «data».
			//	Проверяем поддерживает ли модуль управление подтяжкой линий шины I2C:											//
				if( (data[0] & 0b00000100) == false ){ return false; }															//	Если флаг «FLG_I2C_UP» регистра «REG_FLAGS_0» сброшен, значит модуль не поддерживает управление подтяжкой линий шины I2C.
			//	Проверяем установлена ли подтяжка линий шины I2C:																//
				if( (data[1] & 0b00000100) == false ){ return false; }															//	Если бит  «SET_I2C_UP» регистра «REG_BITS_0»  сброшен, значит подтяжка линий шины I2C не установлена.
				return true;																									//	Возвращаем флаг успеха.
			}else{																												//	Иначе, если модуль не инициализирован, то ...
				return false;																									//	Возвращаем ошибку.
			}																													//
}																																//
																																//
//		Установка подтяжки линий шины I2C:																						//	Возвращаемое значение:	результат установки подтяжки линий шины I2C.
bool	iarduino_I2C_Track::setPullI2C		(bool f){																			//	Параметр:				флаг подтяжки линий шины I2C.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Считываем первые два регистра: регистр флагов и регистр битов:													//
				if(_readBytes(REG_FLAGS_0,2)==false ){ return false; }															//	Читаем 2 байта начиная с регистра «REG_FLAGS_0» в массив «data».
			//	Проверяем поддерживает ли модуль управление подтяжкой линий шины I2C:											//
				if( (data[0] & 0b00000100) == false ){ return false; }															//	Если флаг «FLG_I2C_UP» регистра «REG_FLAGS_0» сброшен, значит модуль не поддерживает управление подтяжкой линий шины I2C.
			//	Устанавливаем или сбрасываем бит включения подтяжки линий шины I2C:												//
				if(f){ data[0] = (data[1] |  0b00000100); }																		//	Если флаг «f» установлен, то копируем значение из 1 в 0 элемент массива «data» установив бит «SET_I2C_UP».
				else { data[0] = (data[1] & ~0b00000100); }																		//	Если флаг «f» сброшен   , то копируем значение из 1 в 0 элемент массива «data» сбросив   бит «SET_I2C_UP».
			//	Сохраняем получившееся значение в регистр «REG_BITS_0»:															//
				if(_writeBytes(REG_BITS_0,1)==false ){ return false; }															//	Записываем 1 байт в регистр «REG_BITS_0» из массива «data».
				delay(50);																										//	Даём время для сохранения данных в энергонезависимую память модуля.
				return true;																									//	Возвращаем флаг успеха.
			}else{																												//	Иначе, если модуль не инициализирован, то ...
				return false;																									//	Возвращаем ошибку
			}																													//
}																																//
																																//
//		Управление подсветкой знака:																							//	Возвращаемое значение:	результат управления подсветкой.
bool	iarduino_I2C_Track::backlight		(uint8_t led_1, uint8_t led_2){														//	Параметры:				led_1 - 0=откл/1=вкл/2=мигать [, led_2 - 0=откл/1=вкл/2=мигать].
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Определяем значение второй цепи светодиодной подсветки:															//
				if( led_2==255 ){ led_2=led_1; }																				//	Если вункция вызвана с 1 параметром, то применяем его значение к обеим цепям светодиодной подсветки.
			//	Определяем битовые маски управления цепями подсветки:															//
				uint8_t mask_1 = 0b00000010;																					//	Определяем маску бита управления 1 цепью светодиодной подсветки знака.
				uint8_t mask_2 = 0b10000000;																					//	Определяем маску бита управления 2 цепью светодиодной подсветки знака.
			//	Определяем значения регистров управления цепями подсветки:														//
				data[0] = (led_1==2 ? mask_1:0) | (led_2==2 ? mask_2:0);														//	Определяем значение для регистра «BLINK_ON» устанавливающего   биты регистра «BLINK».
				data[1] = (led_1==2 ? 0:mask_1) | (led_2==2 ? 0:mask_2);														//	Определяем значение для регистра «BLINK_OFF» сбрасывающего     биты регистра «BLINK».
				data[2] = (led_1    ? mask_1:0) | (led_2    ? mask_2:0);														//	Определяем значение для регистра «DIGITAL_ON» устанавливающего биты регистра «DIGITAL».
				data[3] = (led_1    ? 0:mask_1) | (led_2    ? 0:mask_2);														//	Определяем значение для регистра «DIGITAL_OFF» сбрасывающего   биты регистра «DIGITAL».
			//	Сохраняем 4 байта полученных значений в регистры модуля:														//
				if(_writeBytes(REG_IR1_BLINK_ON,4)==false ){ return false; }													//	Записываем 4 байта в модуль, начиная с регистра «BLINK_ON» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		Управление светодиодом информирующим о передаче данных:																	//	Возвращаемое значение:	результат включения/отключения светодиода информирующего о передаче данных.
bool	iarduino_I2C_Track::indicator		(bool f){																			//	Параметр:				флаг разрешающий работу светодиода.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Читаем текущее состояние регистра битов:																		//	
				if(_readBytes(REG_IR1_BIT,1)==false ){ return false; }															//	Читаем 1 байт из регистра «BIT» в массив «data».
			//	Меняем состояние бита «TX_LED»:																					//
				if( f ){ data[0] |= IR1_BIT_TX_LED; }																			//	Устанавливаем бит «TX_LED» разрешающий работу светодиода информирующего о передаче данных.
				else   { data[0] &=~IR1_BIT_TX_LED; }																			//	Сбрасываем    бит «TX_LED» разрешающий работу светодиода информирующего о передаче данных.
			//	Сохраняем полученный байт в регистр «BIT» модуля:																//
				if(_writeBytes(REG_IR1_BIT,1)==false ){ return false; }															//	Записываем 1 байт в регистр «BIT» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		Выбор протокола передачи данных по ИК-каналу:																			//	Возвращаемое значение:	результат применения нового ИК протокола.
bool	iarduino_I2C_Track::irProtocol		(uint8_t cod){																		//	Параметр:				номер протокола.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
				data[0] = cod & IR1_NUM_CODING;																					//	Готовим номер ИК-протокола передачи данных для записи в модуль.
				if(_writeBytes(REG_IR1_SEND_COD,1)==false ){ return false; }													//	Записываем 1 байт в регистр «SEND_COD» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		Отправка данных по ИК-каналу, однократно:																				//	Возвращаемое значение:	результат отправки данных.
bool	iarduino_I2C_Track::irSend			(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Если модуль определён как светофор:																				//
				if(valIrAdrCom<0x2000){																							//
				//	Считываем текущее состояние регистров «BLINK» и «DIGITAL»:													//
					if(_readBytes(REG_IR1_BLINK,2)==false ){ return false; }													//	Читаем 2 байта начиная с регистра «BLINK» в массив «data».
				//	Определяем команду ИК-устройства по прочитанному состоянию светофора:										//
					data[2] =	(( data[1] & IR1_BIT_TL_RT )								? 0b00000001:0)						//	Указываем что включён или мигает зелёный сигнал поворота на право.
							|	(( data[1] & IR1_BIT_TL_LT )								? 0b00000010:0)						//	Указываем что включён или мигает зелёный сигнал поворота на лево.
							|	(((data[1] & IR1_BIT_TL_GRN) && !(data[0]&IR1_BIT_TL_GRN))	? 0b00000100:0)						//	Указываем что включён зелёный сигнал светофора.
							|	(((data[1] & IR1_BIT_TL_GRN) &&  (data[0]&IR1_BIT_TL_GRN))	? 0b00001000:0)						//	Указываем что мигает  зелёный сигнал светофора.
							|	(((data[1] & IR1_BIT_TL_YEL) && !(data[0]&IR1_BIT_TL_YEL))	? 0b00010000:0)						//	Указываем что включён жёлтый  сигнал светофора.
							|	(((data[1] & IR1_BIT_TL_YEL) &&  (data[0]&IR1_BIT_TL_YEL))	? 0b00100000:0)						//	Указываем что мигает  жёлтый  сигнал светофора.
							|	(( data[1] & IR1_BIT_TL_RED)								? 0b01000000:0)						//	Указываем что включён красный сигнал светофора.
							|	(( data[1] & IR1_BIT_GATE  )								? 0b10000000:0);					//	Указываем что закрыт шлагбаум.
				//	Определяем значения регистров повтора и адреса для ИК-устройства:											//
					data[0] = 0;																								//	Определяем значение для регистра «SEND_RPT»: Интервал между пакетами по умолчанию, не отправлять пакеты повтора.
					data[1] = highByte(valIrAdrCom);																			//	Определяем значение для регистра «SEND_ADR»: Адрес   ИК-устройства. Старший байт переменной valIrAdrCom определён функцией define().
				//	Сохраняем 3 байта полученных значений в регистры модуля:													//
					if(_writeBytes(REG_IR1_SEND_RPT,3)==false ){ return false; }												//	Записываем 3 байта в модуль, начиная с регистра «SEND_RPT» из массива «data».
					return true;																								//	Возвращаем флаг успеха.
			//	Если модуль определён как дорожный знак:																		//
				}else{																											//
				//	Определяем значения регистров повтора, адреса и команды для ИК-устройства:									//
					data[0] = 0;																								//	Определяем значение для регистра «SEND_RPT»: Интервал между пакетами по умолчанию, не отправлять пакеты повтора.
					data[1] = highByte(valIrAdrCom);																			//	Определяем значение для регистра «SEND_ADR»: Адрес   ИК-устройства. Старший байт переменной valIrAdrCom определён функцией define().
					data[2] =  lowByte(valIrAdrCom);																			//	Определяем значение для регистра «SEND_COM»: Команда ИК-устройства. Младший байт переменной valIrAdrCom определён функцией define().
				//	Сохраняем 3 байта полученных значений в регистры модуля:													//
					if(_writeBytes(REG_IR1_SEND_RPT,3)==false ){ return false; }												//	Записываем 3 байта в модуль, начиная с регистра «SEND_RPT» из массива «data».
					return true;																								//	Возвращаем флаг успеха.
				}																												//
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		Ожидание завершения однократной отправки данных по ИК-каналу:															//	Возвращаемое значение:	нет.
void	iarduino_I2C_Track::irWait			(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
				uint32_t tim    = millis();																						//	
				        data[0] = IR1_BIT_TX_BUSY;																				//	
				while( (data[0] & IR1_BIT_TX_BUSY) && ((millis()-500)<tim) ){ _readBytes(REG_IR1_BIT,1); }						//	Читаем 1 байт из регистра «BIT» в массив «data», пока не будет сброшен бит «TX_BUSY» или не проёдет 500 мс.
			}																													//
}																																//
																																//
//		Отправка данных по ИК-каналу, постоянно:																				//	Возвращаемое значение:	результат старта отправки данных.
bool	iarduino_I2C_Track::irAutoSend		(uint8_t tim){																		//	Параметр:				tim - интервал между пакетами повторов в мс. Интервал будет хаотично меняться в пределах ±50% от заданного.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Определяем значение регистра повторов «SEND_RPT»:																//
				if( (tim>0) && (tim<24) ){ tim=24; }																			//	Не позволяем задавать интервалы между пакетами от 1 до 23 мс. Если указан 0, то будет использован интервал по умолчанию.
				data[0] = tim|1;																								//	Определяем значение для регистра «SEND_RPT»: Интервал между пакетами, отправлять пакеты повтора.
			//	Сохраняем 1 байт в регистр модуля:																				//
				if(_writeBytes(REG_IR1_SEND_RPT,1)==false ){ return false; }													//	Записываем 1 байт в регистр «SEND_RPT» из массива «data».
			//	Если модуль определён как светофор:																				//
				if(valIrAdrCom<0x2000){																							//
				//	Считываем текущее состояние регистра «TL_BIT»:																//
					if(_readBytes(REG_IR1_TL_BIT,1)==false ){ return false; }													//	Читаем 1 байт из регистра «TL_BIT» в массив «data».
				//	Устанавливаем бит автоматической отправки текущего состояния светофора по ИК-каналу:						//
					data[0]|=IR1_BIT_TL_AUTOCOM;																				//
				//	Сохраняем 1 байт в регистр модуля:																			//
					if(_writeBytes(REG_IR1_TL_BIT,1)==false ){ return false; }													//	Записываем 1 байт в регистр «TL_BIT» из массива «data».
					return true;																								//	Возвращаем флаг успеха.
			//	Если модуль определён как дорожный знак:																		//
				}else{																											//
				//	Определяем значения адреса и команды для ИК-устройства:														//
					data[0] = highByte(valIrAdrCom);																			//	Определяем значение для регистра «SEND_ADR»: Адрес   ИК-устройства. Старший байт переменной valIrAdrCom определён функцией define().
					data[1] =  lowByte(valIrAdrCom);																			//	Определяем значение для регистра «SEND_COM»: Команда ИК-устройства. Младший байт переменной valIrAdrCom определён функцией define().
				//	Сохраняем 2 байта полученных значений в регистры модуля:													//
					if(_writeBytes(REG_IR1_SEND_ADR,2)==false ){ return false; }												//	Записываем 2 байта в модуль, начиная с регистра «SEND_ADR» из массива «data».
					return true;																								//	Возвращаем флаг успеха.
				}																												//
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		Отмена постоянной отправки данных по ИК-каналу:																			//	Возвращаемое значение:	результат отмены отправки данных.
bool	iarduino_I2C_Track::irStop			(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Считываем текущее состояние регистра «TL_BIT»:																	//
				if(_readBytes(REG_IR1_TL_BIT,1)==false ){ return false; }														//	Читаем 1 байт из регистра «TL_BIT» в массив «data».
			//	Сбрасываем бит автоматической отправки текущего состояния светофора по ИК-каналу:								//
				data[0]&=~IR1_BIT_TL_AUTOCOM;																					//	Сброс бита «AUTOCOM» регистра «TL_BIT» приведёт к сбросу бита «REPEAT» регистра «SEND_RPT», что остановит любую передачу данных.
			//	Сохраняем 1 байт в регистр модуля:																				//
				if(_writeBytes(REG_IR1_TL_BIT,1)==false ){ return false; }														//	Записываем 1 байт в регистр «TL_BIT» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		Автономный режим:																										//	Возвращаемое значение:	результат установки/отключения автономного режима.
bool	iarduino_I2C_Track::offline			(bool f){																			//	Параметр:				флаг установки автономного режима.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Читаем текущее состояние регистра битов:																		//	
				if(_readBytes(REG_IR1_BIT,1)==false ){ return false; }															//	Читаем 1 байт из регистра «BIT» в массив «data».
			//	Меняем состояния битов «AVTO_LOAD» и «SAVE_ALL»:																//
				if( f ){ data[0] |= IR1_BIT_AVTO_LOAD|IR1_BIT_SAVE_ALL; }														//	Устанавливаем бит автозагрузки данных в регистры при старте «AVTO_LOAD» и бит сохранения текущих значений регистров «SAVE_ALL».
				else   { data[0] &=~IR1_BIT_AVTO_LOAD;                  }														//	Сбрасываем    бит автозагрузки данных в регистры при старте «AVTO_LOAD».
			//	Сохраняем полученный байт в регистр «BIT» модуля:																//
				if(_writeBytes(REG_IR1_BIT,1)==false ){ return false; }															//	Записываем 1 байт в регистр «BIT» из массива «data».
				delay(100);																										//	Ждём завершения сохранения данных в flash память модуля.
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		Установка времени свечения цветов светофора:																			//	Возвращаемое значение:	результат применения времени.
bool	iarduino_I2C_Track::timing			(uint8_t grn, uint8_t yel, uint8_t red){											//	Параметры:				grn - время свечения зелёного (от 1 до 127 сек), yel - время свечения жёлтого или мигающего зелёного (от 1 до 127 сек), red - время свечения красного (от 1 до 127 сек).
			if(valAddr){																										//
			//	Читаем текущие значения регистров:																				//
				if(_readBytes(REG_IR1_TL_YEL_SEC,3)==false ){ return false; }													//	Читаем 3 байта начиная с регистра «TL_YEL_SEC» в массив «data».
			//	Заполняем массив данными о времени «grn», «yel», «red», оставляя биты «TL_LT_EN», «TL_RT_EN», «TL_GT_EN»:		//
				data[0] = (data[0]&IR1_BIT_TL_LT_EN) | (yel&~IR1_BIT_TL_LT_EN);													//	Определяем значение для регистра «TL_YEL_SEC».
				data[1] = (data[1]&IR1_BIT_TL_RT_EN) | (grn&~IR1_BIT_TL_RT_EN);													//	Определяем значение для регистра «TL_GRN_SEC».
				data[2] = (data[2]&IR1_BIT_TL_GT_EN) | (red&~IR1_BIT_TL_GT_EN);													//	Определяем значение для регистра «TL_RED_SEC».
			//	Сохраняем данные в регистры модуля:																				//
				if(_writeBytes(REG_IR1_TL_YEL_SEC,3)==false ){ return false; }													//	Записываем 3 байта в модуль, начиная с регистра «TL_YEL_SEC» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
bool	iarduino_I2C_Track::timing			(uint8_t yel){																		//	Параметр:				yel - время свечения жёлтого или мигающего зелёного (от 1 до 127 сек).
			if(valAddr){																										//
			//	Читаем текущее значение регистра:																				//
				if(_readBytes(REG_IR1_TL_YEL_SEC,1)==false ){ return false; }													//	Читаем 1 байт из регистра «TL_YEL_SEC» в массив «data».
			//	Заполняем элемент массива временем «yel» оставляя бит «TL_LT_EN»:												//
				data[0] = (data[0]&IR1_BIT_TL_LT_EN) | (yel&~IR1_BIT_TL_LT_EN);													//	Определяем значение для регистра «TL_YEL_SEC».
			//	Сохраняем данные в регистр модуля:																				//
				if(_writeBytes(REG_IR1_TL_YEL_SEC,1)==false ){ return false; }													//	Записываем 1 байта в регистр «TL_YEL_SEC» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		Управление светофором в ручном и полуавтономном режиме:																	//	Возвращаемое значение:	результат применения нового значения.
bool	iarduino_I2C_Track::set				(uint8_t p01, uint8_t p02, uint8_t p03, uint8_t p04, uint8_t p05, uint8_t p06, uint8_t p07, uint8_t p08, uint8_t p09, uint8_t p10, uint8_t p11, uint8_t p12, uint8_t p13, uint8_t p14){	//	Параметры: [разрешение[,разрешение[,разрешение]]] или [цвет, флаг [,цвет, флаг [,цвет, флаг [,цвет, флаг [,цвет, флаг [,цвет, флаг [,цвет, флаг]]]]]]]
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Сохраняем полученные параметры в массив:																		//
				uint8_t p[14]={p01, p02, p03, p04, p05, p06, p07, p08, p09, p10, p11, p12, p13, p14};							//
			//	Устанавливаем биты в соответствии со значениями параметров:														//	data[0]=«TL_BIT» прочитанное.
				data[1]=0; data[2]=0; data[3]=0; data[4]=0; data[5]=0;															//	data[1]=«BLINK_ON»; data[2]=«BLINK_OFF»; data[3]=«DIGITAL_ON»; data[4]=«DIGITAL_OFF»; data[5]=«TL_BIT»;
				for(uint8_t i=0, j; i<14; i++){																					//
				//	Ручное управление светофором:																				//
					j=0;																										//
					if( p[i] == TL_RED			){ j=IR1_BIT_TL_RED; }															//	Если обнаружен параметр «TL_RED»   , то используем битовую маску IR1_BIT_TL_RED для записи в регистры «BLINK_ON/OFF», «DIGITAL_ON/OFF».
					if( p[i] == TL_YELLOW		){ j=IR1_BIT_TL_YEL; }															//	Если обнаружен параметр «TL_YELLOW», то используем битовую маску IR1_BIT_TL_YEL для записи в регистры «BLINK_ON/OFF», «DIGITAL_ON/OFF».
					if( p[i] == TL_GREEN		){ j=IR1_BIT_TL_GRN; }															//	Если обнаружен параметр «TL_GREEN» , то используем битовую маску IR1_BIT_TL_GRN для записи в регистры «BLINK_ON/OFF», «DIGITAL_ON/OFF».
					if( p[i] == TL_RIGHT		){ j=IR1_BIT_TL_RT;  }															//	Если обнаружен параметр «TL_RIGHT» , то используем битовую маску IR1_BIT_TL_RT  для записи в регистры «BLINK_ON/OFF», «DIGITAL_ON/OFF».
					if( p[i] == TL_LEFT			){ j=IR1_BIT_TL_LT;  }															//	Если обнаружен параметр «TL_LEFT»  , то используем битовую маску IR1_BIT_TL_LT  для записи в регистры «BLINK_ON/OFF», «DIGITAL_ON/OFF».
					if( p[i] == TL_BEEP			){ j=IR1_BIT_TL_BEP; }															//	Если обнаружен параметр «TL_BEEP»  , то используем битовую маску IR1_BIT_TL_BEP для записи в регистры «BLINK_ON/OFF», «DIGITAL_ON/OFF».
					if( p[i] == TL_GATE			){ j=IR1_BIT_GATE;   }															//	Если обнаружен параметр «TL_GATE»  , то используем битовую маску IR1_BIT_GATE   для записи в регистры «BLINK_ON/OFF», «DIGITAL_ON/OFF».
					if( p[i] == TL_ALL			){ j=0xEF;           }															//	Если обнаружен параметр «TL_ALL»   , то используем битовую маску 0b 1110 1111   для записи в регистры «BLINK_ON/OFF», «DIGITAL_ON/OFF».
					if( j						){ i++;																			//
					if( p[i] == 0				){ data[2]|=j; data[4]|=j; }else												//	Отключаем сигнал светофора.
					if( p[i] == 1				){ data[2]|=j; data[3]|=j; }else												//	Включаем  сигнал светофора.
					if( p[i] == 2				){ data[1]|=j; data[3]|=j; }else{ return false; }								//	Устанавливаем мигающий сигнал светофора.
					}else{																										//
				//	Полуавтоматическое управление светофором:																	//
					if( p[i] == TL_FORWARD_OFF	){ data[5]|=IR1_BIT_TL_UP_OFF; }												//	Устанавливаем бит запрещающий движение в прямом направлении.
					if( p[i] == TL_FORWARD_ON	){ data[5]|=IR1_BIT_TL_UP_ON;  }												//	Устанавливаем бит разрешающий движение в прямом направлении.
					if( p[i] == TL_LEFT_OFF		){ data[5]|=IR1_BIT_TL_LT_OFF; }												//	Устанавливаем бит запрещающий движение на лево.
					if( p[i] == TL_LEFT_ON		){ data[5]|=IR1_BIT_TL_LT_ON;  }												//	Устанавливаем бит разрешающий движение на лево.
					if( p[i] == TL_RIGHT_OFF	){ data[5]|=IR1_BIT_TL_RT_OFF; }												//	Устанавливаем бит запрещающий движение на право.
					if( p[i] == TL_RIGHT_ON		){ data[5]|=IR1_BIT_TL_RT_ON;  }												//	Устанавливаем бит разрешающий движение на право.
					}																											//
				}																												//
			//	Запрещаем включать секции поворотников и опускать шлагбаум если их нет:											//
				if( !((valIrAdrCom>>8)&SECTION_L) ){ data[3]&=~IR1_BIT_TL_LT; data[5]&=~IR1_BIT_TL_LT_ON; }						//	Если модуль инициирован функцией begin() без секции левого  поворота, то сбрасываем бит «IR1_BIT_TL_LT» элемента data[3]=«DIGITAL_ON» и бит «IR1_BIT_TL_LT_ON» элемента data[5]=«TL_BIT»;
				if( !((valIrAdrCom>>8)&SECTION_R) ){ data[3]&=~IR1_BIT_TL_RT; data[5]&=~IR1_BIT_TL_RT_ON; }						//	Если модуль инициирован функцией begin() без секции правого поворота, то сбрасываем бит «IR1_BIT_TL_RT» элемента data[3]=«DIGITAL_ON» и бит «IR1_BIT_TL_RT_ON» элемента data[5]=«TL_BIT»;
				if( !flgGate                      ){ data[3]&=~IR1_BIT_GATE;                              }						//	Если модуль инициирован функцией begin() без шлагбаума              , то сбрасываем бит «IR1_BIT_GATE»  элемента data[3]=«DIGITAL_ON»;
			//	Сохраняем изменения выполненные в полуавтоматическом режиме:													//
				if( data[5] ){																									//
				//	Считываем текущее состояние регистра «TL_BIT»:																//
					if(_readBytes(REG_IR1_TL_BIT,1)==false ){ return false; }													//	Читаем 1 байт из регистра «TL_BIT» в массив «data».
					data[0] |= data[5];																							//	Устанавливаем биты полуавтоматического управления светофором.
				//	Сохраняем 1 байт в регистр «TL_BIT» модуля:																	//
					if(_writeBytes(REG_IR1_TL_BIT,1)==false ){ return false; }													//	Записываем 1 байт в регистр «TL_BIT» из массива «data».
				}																												//
			//	Сохраняем изменения выполненные в ручном режиме:																//
				if( data[1]||data[2]||data[3]||data[4] ){																		//
				//	Сохраняем 4 байта полученных значений в регистры модуля:													//
					data[0]=data[1]; data[1]=data[2]; data[2]=data[3]; data[3]=data[4];											//
					if(_writeBytes(REG_IR1_BLINK_ON,4)==false ){ return false; }												//	Записываем 4 байта в модуль, начиная с регистра «BLINK_ON» из массива «data».
				}																												//
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		Установка скорости шлагбаума в автоматическом и полуавтоматическом режиме:												//	Возвращаемое значение:	результат сохранения скорости.
bool	iarduino_I2C_Track::gateSpeed		(uint8_t speed){																	//	Параметр:				speed - скорость от 0 (мин) до 255 (мах).
			if(valAddr){																										//
				data[0]=speed;																									//
			//	Сохраняем 1 байт в регистр «GATE_SPEED» модуля:																	//
				if(_writeBytes(REG_IR1_GATE_SPEED,1)==false ){ return false; }													//	Записываем 1 байт в регистр «GATE_SPEED» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		Установка ширины импульсов ШИМ для управления шлагбаумом в ручном режиме:												//	Возвращаемое значение:	результат применения ширины импульсов ШИМ.
bool	iarduino_I2C_Track::gateWidth		(uint16_t width){																	//	Параметр:				width - ширина импульсов ШИМ от 0 мкс до 20'000 мкс.
			if(valAddr){																										//
			//	Определяем данные для записи в регистры:																		//
				data[0] =  lowByte(width);																						//	Определяем значение для регистра «SERVO_MCS_L»
				data[1] = highByte(width);																						//	Определяем значение для регистра «SERVO_MCS_H»
			//	Сохраняем 2 байта в регистры «SERVO_MCS» модуля:																//
				if(_writeBytes(REG_IR1_SERVO_MCS_L,2)==false ){ return false; }													//	Записываем 2 байта в регистры «SERVO_MCS_L/H» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		Указание ширины импульсов ШИМ при которой шлагбаум будет считаться открытым:											//	Возвращаемое значение:	результат сохранения ширины импульсов ШИМ.
bool	iarduino_I2C_Track::gateWidthOpen	(uint16_t width){																	//	Параметр:				width - ширина импульсов ШИМ от 1 мкс до 19'999 мкс.
			if(valAddr){																										//
			//	Определяем данные для записи в регистры:																		//
				data[0] =  lowByte(width);																						//	Определяем значение для регистра «GATE_OPEN_L»
				data[1] = highByte(width);																						//	Определяем значение для регистра «GATE_OPEN_H»
			//	Сохраняем 2 байта в регистры «GATE_OPEN» модуля:																//
				if(_writeBytes(REG_IR1_GATE_OPEN_L,2)==false ){ return false; }													//	Записываем 2 байта в регистры «GATE_OPEN_L/H» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		Указание ширины импульсов ШИМ при которой шлагбаум будет считаться закрытым:											//	Возвращаемое значение:	результат сохранения ширины импульсов ШИМ.
bool	iarduino_I2C_Track::gateWidthClose	(uint16_t width){																	//	Параметр:				width - ширина импульсов ШИМ от 1 мкс до 19'999 мкс.
			if(valAddr){																										//
			//	Определяем данные для записи в регистры:																		//
				data[0] =  lowByte(width);																						//	Определяем значение для регистра «GATE_CLOSE_L»
				data[1] = highByte(width);																						//	Определяем значение для регистра «GATE_CLOSE_H»
			//	Сохраняем 2 байта в регистры «GATE_CLOSE» модуля:																//
				if(_writeBytes(REG_IR1_GATE_CLOSE_L,2)==false ){ return false; }												//	Записываем 2 байта в регистры «GATE_CLOSE_L/H» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		Чтение данных из регистров в массив data:																				//	Возвращаемое значение:	результат чтения (true/false).
bool	iarduino_I2C_Track::_readBytes		(uint8_t reg, uint8_t sum){															//	Параметры:				reg - номер первого регистра, sum - количество читаемых байт.
			bool	result=false;																								//	Определяем флаг       для хранения результата чтения.
			uint8_t	sumtry=10;																									//	Определяем переменную для подсчёта количества оставшихся попыток чтения.
			do{	result = selI2C->readBytes(valAddr, reg, data, sum);															//	Считываем из модуля valAddr, начиная с регистра reg, в массив data, sum байт.
				sumtry--;	if(!result){delay(1);}																				//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
			}	while		(!result && sumtry>0);																				//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
			delayMicroseconds(500);																								//	Между пакетами необходимо выдерживать паузу.
			return result;																										//	Возвращаем результат чтения (true/false).
}																																//
																																//
//		Запись данных в регистры из массива data:																				//	Возвращаемое значение:	результат записи (true/false).
bool	iarduino_I2C_Track::_writeBytes		(uint8_t reg, uint8_t sum, uint8_t num){											//	Параметры:				reg - номер первого регистра, sum - количество записываемых байт, num - номер первого элемента массива data.
			bool	result=false;																								//	Определяем флаг       для хранения результата записи.
			uint8_t	sumtry=10;																									//	Определяем переменную для подсчёта количества оставшихся попыток записи.
			do{	result = selI2C->writeBytes(valAddr, reg, &data[num], sum);														//	Записываем в модуль valAddr начиная с регистра reg, sum байи из массива data начиная с элемента num.
				sumtry--;	if(!result){delay(1);}																				//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
			}	while		(!result && sumtry>0);																				//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
			delay(10);																											//	Ждём применения модулем записанных данных.
			return result;																										//	Возвращаем результат записи (true/false).
}																																//
																																//